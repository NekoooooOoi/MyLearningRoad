### 跨域
跨域，是指浏览器不能执行其他网站的脚本。它是由浏览器的同源策略造成的，是浏览器对JavaScript实施的安全限制。
同源的定义：域名、协议、端口均为相同。

同源策略限制了以下行为：

- Cookie、LocalStorage 和 IndexDB 无法读取
- DOM 和 JS 对象无法获取
- Ajax请求发送不出去

没有同源策略的接口访问问题：

- 若可以读取本地缓存，则非法网站可以肆意获取cookie内的信息来达成伪装目的
- 非法网站可以诱导你向其他网站接口发送请求，达成伪造你发送请求的目的

跨域解决方案

- 跨域资源共享CORS（Cross-Origin Resource Sharing）

CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。服务器决定接受哪些地址发送的请求，并在请求头添加Access-Control-Allow-Origin相关信息。

- 反向代理

反向代理不存在跨域，浏览器不需要向其他域发送请求，此项工作由代理服务器或者网关完成。

### CSRF攻击
跨站请求伪造（英语：Cross-site request forgery）是一种对网站的恶意利用，也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。 CSRF跨站点请求伪造(Cross—Site Request Forgery) 跟XSS攻击一样，存在巨大的危害性。
你可以这样来理解：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。        
简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品），此次访问会携带cookies等信息（即使攻击者无法获取这些信息的内容，但仍可以达到伪装用户的目的）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。   
 ![csrf_1.jpeg](./images/csrf_1.jpeg)

CSRF攻击的防御：CSRF攻击防御的重点是利用cookie的值只能被第一方读取，无法读取第三方的cookie值。
防御策略：

- 预防csrf攻击简单可行的方法就是在客户端网页上再次添加一个cookie，保存一个随机数，而用户访问的时候，先读取这个cookie的值，hash一下这个cookie值并发送给服务器，服务器接收到用户的hash之后的值，同时取出之前设置在用户端的cookie的值，用同样的算法hash这个cookie值，比较这两个hash值，相同则是合法。（如果用户访问了病毒网站，也想带这个cookie去访问的时候，此时，因为病毒网站无法获取第三方cookie的值，所以他也就无法hash这个随机数，所以也就会被服务器校验的过滤掉）
- 也可以验证 HTTP Referer 字段确定HTTP请求的来源地址

### SpringSecurity
![springsecurity_1.png](./images/springsecurity_1.png)
SpringSecurity的原理是一系列的过滤器链，根据不同的验证规则去验证来源的认证和授权是否合法。
![springsecurity_2.png](./images/springsecurity_2.png)
