OSTEP课件地址：https://github.com/remzi-arpacidusseau/ostep-translations/tree/master/chinese

## 虚拟化CPU

进程的创建：

- 加载在程序执行期间会执行的代码和静态数据到内存中
- 为程序的运行时栈分配一些内存，用于存放局部变量、函数参数和返回地址
- 为程序的堆分配一些内存，在 C 程序中，堆用于显式请求的动态分配数据
- 执行I/O的初始化任务

进程的数据结构

- 内存的起始地址和内存占用大小
- 进程内核栈的栈底位置（内核栈是陷入内核之后使用的栈，可以在切换时用来保存一些寄存器的值）
- 进程状态，进程PID，父进程
- 上下文
- 页表(CPU会有寄存器记录当前进程的页表起始位置和长度)

进程相关API（Linux系统调用)

- int fork() 创建一个子进程，父进程和子进程同时从函数结束处继续运行，子进程在此处返回为0，父进程则返回值为子进程PID。
- int wait() 父进程调用后阻塞等待子进程结束，返回值为子进程PID。
- exec() 在子进程中调用使子进程执行和父进程不同的程序。exec()会从选择的可执行程序中加载代码段数据段等覆盖自己的，达到运行其他程序的目的，exec()的成功调用永远不会返回。
- int pipe(int fd[2]) 创建管道通信：构建两个**阻塞**的文件描述符，fd[1]只能用来写，fd[0]只能用用来读

机制：受限直接执行

- 受限制的操作：在用户模式下运行的代码会受到限制，如不能发出I/O请求；在内核模式下，运行的代码可以做它喜欢的事，包括特权操作，操作系统以此运行。当用户程序想要执行系统调用时，程序必须执行特殊的陷阱（trap）指令。该指令同时跳入内核并将特权级别提升到内核模式。完成后，操作系统调用一个特殊的从陷阱返回 （return-from-trap）指令，并且回到程序中调低等级。
- 利用时钟中断重新获得控制权：操作系统通过添加时钟中断定期获得在CPU上重新运行的能力。

进程的上下文切换：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值（例如，到它的内核栈），并为即将执行的进程恢复一些寄存器的值（从它的内核栈）。为了保存当前正在运行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针，然后**恢复寄存器、程序计数器，并切换内核栈**，供即将运行的进程使用。

进程调度：公平性、平均周转时间、响应时间（周转时间=完成时间-到达时间，响应时间=首次执行时间-到达时间）

- 多级反馈队列（单处理器）：有不同优先等级的队列，抢占式地运行高优先级的队列的任务；任务刚开始都会处于最高优先级，当分配的时间片用完后优先级下调到下一队列，优先级越高时间片越短；定期将所有任务放入高优先级。
- 多处理器：1、基于单队列的方式：将所有需要调度的工作放入一个单独的队列中，每个CPU依次从队列中取任务执行。缺点是扩展性不好，不能很好的保证缓存亲和度。2、基于多队列的方式：分出多个队列存储任务，扩展性和缓存亲和性很好，但是很难解决负载不均的问题（例如一个CPU有很长的队伍另一个没有任务，实现负载的均衡分配需要引入更多机制降低性能）。

局部性原理：局部性有两种，即时间局部性和空间局部性。 时间局部性是指当一个数据被访问后，它很有可能会在不久的将来被再次访问，比如循环代码中的数据或指令本身。而空间局部性指的是，当程序访问地址为 x 的数据时，很有可能会紧接着访问 x 周围的数据，比如遍历数组或指令的顺序执行。

## 虚拟化内存

目标：

- 透明：程序不应该感知到内存被虚拟化的事实，相 反，程序的行为就好像它拥有自己的私有物理内存。程序会认为自己具有一块很大的连续的物理地址空间，而不用去担心应该在什么空间存放自己的数据。
- 效率：虚拟化内存追求尽可能的高效，在时间上（程序运行不会变慢）在空间上（不需要太多额外的内存支持虚拟化）。
- 保护：进程的运行应该受到保护，当一个进程执行加载、存储或指令提取时，它不应该以任何方式访问或影响任何其他进程或操作系统本身的内存内容。

进程内存的两级管理：1、在用户态的堆内malloc()和free() 2、操作系统在运行时将内存交给进程，在进程退出后会自动回收。两级管理让进程在退出时没有内存泄漏。

#### 地址转换

CPU的内存管理单元MMU：包含负责地址转换的基址寄存器和界限寄存器，基址寄存器负责将虚拟内存地址转换为物理内存地址，界限寄存器提供了访问保护。地址转换操作完全由硬件处理。

空闲列表：

- 为了分配内存，操作系统必须记录哪些空闲内存没有使用，可以简单的采用一个空闲列表来记录当前没有使用的物理内存的范围。

- 空闲列表需要做到分割和合并，合并即将连续多个空闲地址转换成一个
- 分割具有一些基本策略：
  - 最优匹配：遍历全列表去查找大于需求内存的最小空闲内存去容纳
  - 最差匹配：遍历全列表去找一个最大的空闲内存去分配
  - 首次匹配：遍历查找，遇到第一个能提供需求内存大小的空闲内存就进行分配，不用遍历全局
  - 下次匹配：从上一次匹配的地址开始遍历查找，遇到第一个能提供的就分配

内存分段：引入三对基址寄存器和界限寄存器，为代码段，堆，栈各分配一个。如何定位到具体使用哪个寄存器呢？可以在虚拟内存中分配一些比特记录是属于什么段的。缺点是会造成外部碎片和灵活性差。

****

内存分页：将内存分为大小相同的页，存在的问题是：每次地址转换需要多一次内存访问（TLB解决），页表太大（多级页表或者段页式分离解决）。

页表的结构：1、有效位：正在使用的页标记为有效，访问无效地址操作系统会发送信号，如果没有相应的捕获机制会杀死进程。2、保护位：指定读写权限。3、存在位：表明存在于磁盘上还是内存上。4、脏位：页是否被修改过。5、参考位：用于追踪页是否被访问。

页表分为用户页表和内核页表，内核页表一般指的是内核地址空间的页表，用户页表表示用户地址空间的，他们都存储在内核空间中。每个进程有各自的页表，但是内核的页表只有一个，所以进程上下文切换指向当前进程页表的相应的寄存器会发生更改。一般虚拟地址空间的上半部分属于内核空间，对于每个进程而言都是相同的，虚拟地址的下半空间属于用户空间，对于每个进程都是唯一的。

TLB快表（硬件缓存）：对每次内存访问，硬件先检查 TLB，看看其中是否有期望的转换映射，如果有，就完成转换（很快），不用访问页表 （其中有全部的转换映射）；如果没有，就访问页表寻找映射然后更新TLB，开销会比较大因为在访问时由额外的一次内存引用。

进程的上下文切换：TLB快表有两种形式，1、不具有地址空间标识符ASID（类似于PID），则每次切换要清空TLB 2、具备ASID，则每次切换的时候不需要清空TLB。无论如何TLB的命中都会下降。

段页结合：将虚拟地址的高几位用于区分属于哪一段。

多级页表：页目录+页表。使用页目录记录哪些页表被分配，得以让之前线性页表的一部分消失。多级页表分配的页表空间，与你正在使用的地址空间内存量成比例。多级页表的成本式TLB未命中时需要加载2次。

****

**换入换出**

交换空间：在硬盘上开辟一部分空间用于物理页的移入和移出，一般这样的空间叫做交换空间。交换空间不是唯一的换入换出的区域，例如程序的代码段可以从内存中直接移除，稍后可以再从磁盘加载。

页错误：当需要的页面存储于磁盘上时会出发页错误，操作系统会为将要换入的页找到一个物理帧，如果没有的话会进行交换算法踢出一些内存供使用，在获得物理帧后更新TLB。

****

按需置零：当操作系统为一个进程分配了新的物理页映射后应该将其置零，以免进程读取到之前进程的内容，但是效率低。具体的做法是设置有效位，当需要用到的时候再去更改内容和有效位。

写时复制：如果操作系统需要将一个页面从一个地址空间复制到另一个地址空间，不是实际复制它，而是将其映射到目标地址空间，并在两个地址空间中将其标记为只读。

## 并发

进程和线程共享一个地址空间但是不共享一个内核栈。

死锁的条件：互斥、持有并等待、非强占、循环等待。如果有一个没有满足死锁就不会产生。

#### 死锁避免--破除死锁的条件

循环等待：获取锁的时候提供全序或者偏序，即让锁的获取顺序定下来。

持有并等待：可以通过原子地抢锁来避免，例如可设置一个全局锁，然后在获得需要的锁的前后加上全局锁，保证获取需要的锁的过程是一个原子过程。

非抢占：每次加锁使用tryLock()，如果失败则放弃之前获得的锁

互斥：可以使用CAS避免互斥

通过调度避免死锁：如果线程1和线程2都需要锁L1和锁L2，那么不让他们同时运行就可以。e.g.,银行家算法

## 持久化

#### I/O设备

标准设备会具有外部的硬件接口（如状态、指令、数据寄存器等）用来和软件通信，也会有内部结构（CPU、芯片、缓存等）来负责接口的具体实现。

一个（简化的）设备接口包含 3 个寄存器：一个状态（status）寄存器， 可以读取并查看设备的当前状态；一个命令（command）寄存器，用于通知设备执行某个具 体任务；一个数据（data）寄存器，将数据传给设备或从设备接收数据。通过读写这些寄存 器，操作系统可以控制设备的行为。

I/O设备的具体执行：进程A运行，发出I/O请求，然后CPU切换到进程B。此时CPU会让DMA负责将数据写入到磁盘的缓存中，DMA完成后会触发一个中断。然后CPU会让磁盘从磁盘的缓存中写入到磁盘内部，磁盘工作完成后会触发一个中断。然后CPU可以切换到进程A。

I/O设备的具体交互方式：1、明确的 I/O 指令：规定了操作系统将数据发送到特定设备寄存器的方法。2、内存映射 I/O：硬件将设备寄存器作为内存地址提供，当需要访问设备寄存器时，操作系统装载（读取）或者存入（写入）到该内存地址；然后硬件会将装载/存入转移到设备上，而不是物理内存。

设备驱动程序：文件系统栈为 应用程序-->文件系统-->通用块层（提供统一接口）-->设备驱动程序。文件系统（当然也包括在其之上的应用程序）完全不清楚它使用的是什么类型的磁盘。它只需要简单地向通用块设备层发送读写请求即可，块设备层会将这些请求路由给对应的设备驱动，然后设备驱动来完成真正的底层操作。

##### 磁盘驱动器

磁盘由许多盘片组成，每个盘片由许多磁道组成，每个磁道都是盘片上以主轴为圆心的同心圆，每个磁道可以分为多个扇区，一般一个扇区的大小是512KB。

在运行的过程中，每个磁盘会逆时针旋转，磁盘臂上的磁头负责去读写。磁盘的IO时间为：寻道时间（寻找具体磁道的时间）+旋转时间（磁头等待盘片旋转到相应扇区的时间）+传输时间。所以需要尽可能的顺序读写磁盘。

##### 廉价冗余磁盘阵列（RAID）

从外部看，RAID 看起来像一个磁盘：一组可以读取或写入的块。在内部，RAID 是一 个复杂的庞然大物，由多个磁盘、内存（包括易失性和非易失性）以及一个或多个处理器来管理系统。

RAID0级：条带化，以条带的形式将所有的块存放到磁盘中，没有冗余，缺点是故障无法修复。

RAID1级：镜像，每个块会变成两份存储在不同的磁盘中

RAID4级：通过奇偶校验节省空间，用单独的一个磁盘作为其他磁盘的奇偶校验码，这样某个磁盘的内容丢失了可以通过其他磁盘恢复。

#### 文件系统

##### 文件和目录

文件：文件就是 一个线性字节数组，每个文件有自己的inode号。

目录：目录像文件一样，也有inode号，但内容很具体，包含一个（用户可读名字，inode号）对的列表，目录中的每个条目都指向文件或其他目录。

##### LINUX命令及系统调用（加粗表示linux命令）

系统调用int open()：返回文件描述符，是每个进程私有的。每个正在运行的进程打开了三个文件：0--标准输入（进程可以读取以接收输入），1--标准输出（进程 可以写入以便将信息显示到屏幕），以及2--标准错误（进程可以写入错误消息）。

- **pwd**  显示用户当前所在的目录

- **ls [选项] [目录或文件]** 对于目录，该命令列出该目录下的所有子目录与文件。对于文件，将列出文件名以及其他信息

- **man** 查看linux命令

- **grep** 用于查找文件里符合条件的字符串

- **find **用来在指定目录下查找文件

- **chmod** 用来控制用户对文件的权限的命令；权限显示位一共为10位，分为四段，从第二位算起，每三个一组：第1位代表文件类型（`-`表示为普通文件）第2-4位代表文件所属用户拥有的权限，第5-7位代表该用户所属组拥有的权限，第8-10位代表其他用户拥有的权限。权限以rwx表示（读写执行），没有的权限会以-代替，如r--表示只读。

- **ps** 用来列出系统中当前正在运行的那些进程

- **netstat** 查看端口

- **ping** 检测是否联通

读写文件： **echo** 为打印一些内容，**cat**为查看文件内容。**cat**调用了系统调用open(), read(), write(), close() 等负责读取文件内容并输出到屏幕上。write()是延迟写入，fsync()可以立即写入到磁盘中。

- **mv source_file target_name** 移动文件或者将文件重命名（重命名是通过移动完成的）

- **rm file_name** 删除文件 系统调用为unlink()

查看文件信息：**stat file_name** 可以查看文件的修改时间、权限及一些访问信息。系统调用为stat()

- **mkdir** 创建目录
- **rmdir** 删除空目录
- **rm** 删除文件或目录 -f表示强制 -r表示递归

硬链接：link()系统调用有两个参数：一个旧路径名和一个新路径名。当你将一个新的文件名“链接”到一个旧的文件名时，你实际上创建了另一种引用同一个文件的方法。其inode号相同，inode结构中会有引用计数。硬链接不可以链接其他磁盘的内容或者创建目录的硬链接。

符号连接：符号链接是文件和目录之外的第三种文件类型，将一个文件映射到具体的一个地址，可能存在悬空引用（源文件已被删除但链接依然存在的现象）。

创建并挂在文件系统：使用**mount souce_dir target_dir_node**命令将新的文件系统粘贴到目录树的 这个点上。

##### 文件系统及实现

文件系统的数据结构：首先对磁盘分成不同的块。

- 大部分存储用户数据的地方叫做数据块。
- inode结构记录诸如文件包含哪些数据块（在数据区域中）、文件的大小， 其所有者和访问权限、访问和修改时间以及其他类似信息，为了存放inode，会有一个inode表。
- inode位图和数据位图用以记录哪些inode和哪些数据块已经被分配
- 超级块：记录文件系统的信息，有多少个数据库及inode等

文件组织inode(index node)：每一个inode都会有一个inumber的隐式引用，通过inumber我们可以直接计算磁盘上相应节点的位置。inode 中有一个或多个直接指针（磁盘地址），还有间接指针（指向数据块，但是数据块存放的是直接指针或者间接指针，用来表示大数据文件）。

目录组织：对于给定目录中的每个文件或目录，目录的数据块中都 有一个字符串和一个数字。删除一个文件(如unlink())，会在目录中间留下一段空白空间，会有一些方法来标记他（如用一个保留的 inode 号，比如 0）

**文件的访问--发出一个 open("/foo/bar", O_RDONLY)调用**

所有遍历都从文件系统的根开始，文件的根目录节点是已经存储在内存中的。一旦根节点 inode 被读入，文件系统可以在其中查找指向数据块的指针，数据块包含根目录的内容。通过读入一个或多个目录数据块，它将找到 foo 的条目。一旦找到，文件系统也会找到 下一个需要的 foo 的 inode 号。下一步是递归遍历路径名，直到找到所需的 inode。在这个例子中，文件系统读取包含 foo 的 inode 及其目录数据的块，最后找到 bar 的 inode 号。open()的最后一步是将 bar 的 inode 读入内存。然后文件系统进行最后的权限检查，在每个进程的打开文件表中，为此进程分 配一个文件描述符，并将它返回给用户。

**文件的访问--写入文件** 要创建一个文件，文件系统不仅要分配一个 inode，还要在包含新文件的目录中分配空间。这样做的 I/O 工作总量非常大：一个读取 inode 位图（查找空闲 inode），一个写入 inode 位图（将其标记为已分配）， 一个写入新的 inode 本身（初始化它），一个写入目录的数据（将文件的高级名称链接到它 的 inode 号），以及一个读写目录 inode 以便更新它。

**缓存**

可以看到文件I/O的消耗非常大，现在的做法是通过动态划分，统将虚拟内存页面和文件系统页面集成到统一页面缓存中。缓存可以减少读取I/O的流量，但是写入流量无法减少。写缓存可以通过延迟写入，文件系统可以将一些更新编成一批（batch），放入一组较小的 I/O 中(write())。也可以立即写入(fsync())。

##### 崩溃一致性：FSCK 和日志

一次文件的写入需要三次磁盘I/O：更新inode，数据位图以及数据块，中间的崩溃会导致信息不一致。

文件系统检查程序FSCK：它在文件系统挂载并可用之前运行，检查文件中的各种模块的信息是否一致并且更改不一致的地方，缺点是全盘扫描会特别慢。

预写日志：在进行文件写入之前先写入一个日志，日志中的内容以事务形式存在，当日志提交后再进行数据的更新。

##### Fast File System (FFS)

让文件系统的结构和分配策略具有“磁盘意识”:将磁盘划分为一些分组，称为柱面组。每个组中都有超级块的一个副本，其他的内容则是inode/数据位图，inode表/数据块。通过将相关的数据放到一个块中FFS让访问更加迅速，如将文件的数据块分配到与其 inode 相同的组中，将位于同一目录中的所有文件，放在它们所在目录的柱面组中。

##### Log-structured File System（LFS）

磁盘流量越来越多的由写入组成，所以需要考虑专注于写入性能的文件系统，于是LFS诞生了，它会将所有的内容顺序写入。

- 将要写入的内容储备在写入缓冲区中，然后定时向磁盘写入。
- 具体在磁盘中的分布为：数据块+inode+最新的inode映射(所有的inode及其对应的inode的地址)。数据块和inode会分布在磁盘的各个位置，并且inode映射也会有许多旧版本分布在磁盘上。当需要查找inode的时候就会通过最新的inode映射找到目标inode，在inode中会存储数据块的地址，由于inode和数据块是紧邻的，所以查询速率也会很快。
- LFS在磁盘上有个固定位置，称为检查点区域，检查点区域会存储最新inode映射的位置。
- 垃圾收集：由于会出现很多旧的inode映射以及旧的inode和数据块，所以LFS会定期按段去执行清理工作，查找旧版本的inode及失效的inode和数据块（通过最新版本的inode映射去查看是否失效），然后将有效的inode移动到最新的区域M，将原来的区域清空。

##### 数据完整性和保护

潜在扇区错误：如磁头由于某种原因接触到表面会导致数据不可读

块讹误：磁盘将正确的数据写入到错误的位置

解决方法：在数据块后面增加一个记录数据正确与否以及数据物理位置的校验和

- 对于潜在扇区错误，校验和错误的话可以去查询RAID存储的镜像
- 对于块讹误，物理位置校验和可以检测出问题

