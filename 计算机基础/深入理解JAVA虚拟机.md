## JAVA内存区域与内存溢出异常

##### 运行时数据区域

- 程序计数器：是一块较小的内存空间，是线程私有的，记录了正在执行**非本地方法**的字节码指令的地址。
- 虚拟机栈：线程私有的，每个方法被执行的时候，JVM都会同步创建一个栈帧，用于存储局部变量表、操作数栈、动态链接等信息。局部变量表存放了编译器已知的基本数据类型、对象引用等，这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)表示，当进入一个方法时，需要分配多大的局部变量空间是确定的。
- 本地方法栈：执行本地方法时的栈，线程私有。
- 堆：在虚拟机启动时创建，几乎所有的对象实例都在这里分配内存。（有些是编译器优化后栈上分配）
- 方法区：用于存储被JVM加载的类型信息、运行时常量池、静态变量等数据。Class文件中除了类的版本、方法、接口等信息外还有一张常量池表，用于存放编译器生成的各种字面常量和符号引用，这些将在类加载后放入到运行时常量池中。

##### 对象的创建

- 首先会检查能否在常量池中定位到一个类的符号引用，并去检查这个类是否已被加载、解析和初始化
- 类加载后，会在堆中为新生对象分配内存（分配多少在加载时就已确定），会通过“指针碰撞”或者空闲列表去寻找内存（具体看垃圾回收算法）。
- 保证分配空间的原子性：1、使用CAS的方式去分配内存 2、为每一个线程分配一块本地线程分配缓冲（TLAB），当本地缓冲区使用完了才会利用CAS的方式去分配。
- 分配完成后会将对象初始化为0值，然后对对象头进行设置（Mark Word,Klass Word)
- 执行对象的<init>()方法，对其进行初始化

对象的组成：对象头+实例数据+对其填充（对象头已经经过填充了，Hot Spot要求对象起始地址是8的倍数，所以有时最后还会有对齐填充）

内存溢出：堆栈溢出一般会有明显的提示、方法区溢出（永久代有默认大小，JDK8后使用元空间就很难溢出了）、直接内存溢出（一般溢出时堆的快照会很小）

## 垃圾收集器与内存分配策略

##### 判断对象是否已死

- 引用计数法：根据对象的引用次数来，但是无法解决循环引用
- 可达性分析：GC Roots作为起始点集，从这些点开始根据引用关系向下搜索，不可达的的对象则为死亡对象。一般的GC Root对象（被同步锁持有的对象（synchronized），线程引用的对象（虚拟机栈中的），方法区中引用的对象（静态变量，字符串常量池等））

引用概念：

- 强引用：传统的引用如"Object obj = new Object();"，只要强引用关系在就不会被垃圾回收
- 软引用：在垃圾回收时如果内存不够才会进行垃圾回收，使用SoftReference类实现
- 弱引用：在每一次垃圾回收时都会被回收，使用WeakReference类实现
- 虚引用：一个对象是否有虚引用不会影响他的生存，虚引用无法获得引用对象。当一个对象被回收时，他如果有虚引用则会将虚引用加入引用队列，虚引用出队后再回收，实现一个系统通知的效果，使用PhantomReference类实现

对于分析不可达的对象，回收会经历两个阶段：1、先判断是否可达，不可达的对象会进行第一次标记 2、如果没有覆盖finalize()方法或者finalize()方法已经被调用过（只能调用一次）则认为没有必要执行finalize（）。如果被判断为需要执行的话会加入到一个F-Queue队列中并依次执行，但不保证方法执行成功。第二次标记后就会进行垃圾回收。

方法区回收：对于一些没有被引用的常量会进行回收，对于一些不再使用的类会进行卸载。

### 垃圾收集算法

##### 分代收集理论

- 弱分代假说：大多数对象都是朝生夕灭的
- 强分代假说：熬过多次垃圾收集的对象很难消亡
- 跨代引用假说：跨代引用相对于同代引用只占少数，（所以只需要在新生代上记录一个记忆集，来记录哪些老年代存在跨代引用，方便新生代的回收）

概念明晰：

- Minor GC：新生代的回收
- Partial GC：
  - 新生代收集 Young GC/ Minor GC
  - 老年代收集 Old GC/ Major GC ：一般只有CMS才有
  - 混合收集 Mixed GC：收集新生代和部分老年代，一般是G1
- Full GC:收集整个堆和方法区的垃圾。

标记+清除算法：标记耗时长，会存在内存碎片

标记+复制算法：在可回收对象很多时很有效，内存更紧凑，但是内存利用率低

标记+整理：复制算法在存活率高的时候效率很低，标记后会移动对象让内存更紧凑，会STW

##### Hot Spot垃圾回收细节

根节点枚举：根节点枚举的过程是要STW的，为了根节点的引用关系不会在开始变化，否则分析结果兼顾不准确。Hot Spot是会用一组OopMaps的数据结构来记录引用的位置，这样就不用每次都去扫描GC Roots

安全点：每个位置都生成OopMaps消耗太大，于是只会在特定的安全点记录这些信息。所以垃圾回收必须等待程序到达安全点后才能开始收集。多线程的时候安全点的等待有2种方式：1、垃圾回收时对所有线程进行中断，让还没有运行到安全点的线程运行到安全点 2、垃圾回收时设置一个标志位，每个线程会去轮询查看这个标志位，如果发现标志位被设置了就运行到安全点停下来

安全区域：使用安全点的话无法处理被阻塞的线程。安全区域能确保在某一个代码段中引用关系不会发生变化，当线程进入到安全区域中会标记自己进入到了安全区域。

记忆集与卡表：通过记忆集或者卡表来记录跨代引用，然后加入GC Roots一并扫描。

**并行的可达性分析**：在标记的过程中引用关系会发生变化，可能存在应该存活的对象被错误回收的情况。引入三色标记法作为推导工具：

 - 白色：对象没有被垃圾回收器访问过
 - 黑色：对象以及对象的所有引用都被垃圾回收器访问过（不会再进行访问）
 - 灰色：对象已被访问过，但是存在一个或以上的引用没有被访问过（灰色处于白色和黑色节点之间）

当且仅当在进行可达性分析过程中赋值器为黑色节点插入了一条或多条新的白色引用，并且灰色节点到**该白色节点**的引用全部被删除才会发生存活对象被错误回收的情况。于是可以破坏上述的条件来解决对象消失的问题：

- 增量更新：破坏第一个条件，扫描过程中的新插入的白色引用会被记录下来，扫描结束后再访问一次（CMS）
- 原始快照：破坏第二个条件，当灰色节点要删除引用时会将删除的引用记录下来，扫描结束后再访问一次（G1）

#### 垃圾回收器

Serial（新-复制）/Serial Old（老-整理）：串行回收器，一个线程回收，其他线程阻塞

Parallel Scavenge（新-复制）/Parallel Old（老-整理）：注重吞吐量的回收器，所有线程一起回收

CMS（老年代-标记+清除）：无法处理浮动垃圾，可能会导致内存碎片不足以存放完整对象

Garbage First：将连续的JAVA堆分成大小相同的多个区域，每个区域都可以根据需要扮演新生代，老年代和幸存区。有一类特殊的Humonogous区域专门用于存储大对象。G1将区域作为回收的最小单元，所以可预测停顿时间。G1整体来看是标记+整理，局部区域之间是标记+复制。

 - 卡表：每个 Region会维护一个哈希结构的卡表，记录了我指向谁和谁指向我（存在老年代指向新生代的情况，避免在minor GC时需要扫描全堆)
 - 并发标记阶段：除了使用原始快照的方式之外，G1为每个Region分配了一块区域专门用于存放并发回收时产生的新对象，会有一个指向这个区域起始位置的指针TAMS，G1默认指针位置之上存放的他们都是存活的
 - G1工作流程：
   - 初始标记：记录GC Roots以及更改TAMS的值，会STW
   - 并发标记：并发扫描可回收对象
   - 最终标记：STW处理并发阶段结束后遗留下来的对象，会STW
   - 筛选回收：更新Region的统计数据，对回收价值和成本进行排序，根据用户期望暂停时间来选择Region进行回收，会STW

##### 内存分配策略

- 对象首先在Eden分配，Eden没有足够空间时会发生一次Minor GC
- 大对象直接进入老年代
- 长期存活的对象将进入老年代，每个对象的对象头中有一个年龄计数器
- 动态年龄判定：如果幸存区相同年龄大小的对象大于幸存区空间的一半，那么大于等于这个年龄的就可以进入老年去
- 空间分配担保：在发生Minor GC时，虚拟机会先检查老年代最大可用连续空间是否大于新生代所有对象的空间，如果不成立的话则会查看相关参数看是否允许冒险进行Minor GC，如果不允许冒险的话就要进行一次Full GC。原因是新生代的存活对象如果过多并且大于幸存区的话就需要老年代进行担保，直接进入到老年代中。

##### 基础故障处理工具

- jps:可以列出正在运行的虚拟机进程和虚拟机执行主类
- jstat:监视虚拟机各种运行状态信息的命令行工具
- jmap:用于生成堆存储快照
- jstack:用于生成现在时刻的线程快照
- Jconsole:可视化监视程序，可以监视运行线程、堆、类等各种信息

## 类文件结构

- 魔术和class版本：旧版本的JDK无法访问新版本的class
- 常量池：常量池中有字面量（final 修饰的常量）以及符号引用（如类全限定名等）
- 类的访问标志，类索引/父类索引用以确定全限定名
- 字段表集合：描述接口或者类中声明的变量等，是元数据的描述
- 方法表集合：和字段表类似，描述访问标志、方法索引等，是元数据的描述；如果是父类的方法表或者字段表子类没有进行重写的话，那么不会出现在类文件结构中
- 属性表集合：class文件/字段表/方法表都可以带有自己的属性，描述了具体的内容
  - Code属性：记录了方法的字节码、操作数栈最大值、局部变量所需空间、异常表等
    - load 将局部变量加载到操作数栈
    - store 将操作数栈存储到局部变量槽
    - push 将常量加载到操作数栈
  - MethodParameters: 记录了方法的各个形参名称和信息

#### 虚拟机类加载机制

类的生命周期：加载-->验证-->准备-->解析-->初始化-->使用-->卸载

类必须进行初始化的情况

- new或者对静态**非常量**内容的访问
- 需要进行反射
- 需要初始化子类的时候父类还没有初始化，则先初始化父类
- 虚拟机启动时的主类需要首先初始化

加载

- 通过类的全限定名来获取定义此类的二进制字节流
- 将二进制字节流中的静态存储结构转化为方法区的运行时数据结构
- 在内存中生成一个代表该类的java.lang.Class对象用于提供数据的访问接口

验证：这一阶段是保证Class文件的字节流中包含的信息符合约束要求

准备：这一阶段为静态变量分配内存并且赋予初始值

解析：解析阶段将常量池内的符号引用替换为直接引用

初始化：初始化阶段执行<clinit>()方法，这个方法是编译器自动收集类中所有类中静态块/静态变量的赋值动作产生的。类的初始化有线程安全的保证。

#### 类加载器

任意一个类和其类加载器一起确定了它在JVM中的唯一性，每一个类加载器都有一个独立的类名称空间。所有的相等比较如equals(), instanceof的比较等只有在这两个类是由同一个类加载器加载的情况下才有意义。

##### 双亲委派模型

启动类加载器(Bootstrap Class Loader)：由C++实现，是JVM的一部分，负责加载 <JAVA_HOME>\lib下的路径

扩展类接载器(Extension Class Loader)：系统类库的扩展机制

应用程序加载器(Application Class Loader)：加载用户类路径上的所有类库

双亲委派模型：如果一个类加载器收到了一个类加载请求，它不会首先自己去尝试加载这个类，而是把这个请求委派给父加载器完成，每一个层次的加载器都是如此，只有当父加载器无法完成加载请求的时候才会由自己尝试加载。双亲委派模型让类和其类加载器具备了一种带优先级的层次关系，例如能保证java.lang.Object类在各种加载器环境下都是一个类。

破坏双亲委派模型：有些服务需要父加载器去委托子加载器完成类加载。如线程上下文加载器（这个加载器默认为应用程类加载器），JNDI服务可以通过线程上下文类加载器去加载所需要的SPI服务代码。

#### 虚拟机字节码执行引擎

#### 运行时栈帧结构

同一时刻、同一线程种只有位于栈顶的方法是在运行的，被称为当前栈帧。栈帧存储了方法的局部变量表、操作数栈、动态链接和方法返回地址等信息。

##### 局部变量表

局部变量表的容量以局部变量槽位最小单位，可以存放32位及以下的数据，long和double占据两个槽位。局部变量表存储了this以及输入参数，局部变量表的槽位是可以重用的（不被使用的局部变量所占据的槽位可以放入其他局部变量）。局部变量没有“准备阶段”，没有赋值是无法使用的。

##### 操作数栈

在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容。操作数栈中的元素的类型必须和字节码序列严格匹配（例如iload对应int变量）

##### 动态连接

每个栈帧都包含一个指向运行时常量池该栈帧所属的方法的引用。

##### 方法返回地址

当方法正常调用完成或者异常调用完成（遇到异常导致方法退出）后，都必须返回到最初方法被调用的位置。

#### 方法的调用

方法的调用是通过解析和分派完成的，这两个并不是排斥的关系，而是在不同层次上去筛选和确定方法的过程。

##### 解析

在解析阶段，类加载器会将静态方法、私有方法、final修饰的方法的符号引用解析为直接引用，这些称为“非虚方法”

##### 分派

**静态分派**：Human h1 = new Man(); Human为**静态类型**，Man为**实际类型**。所有依赖静态类型来决定方法执行版本的分派动作都叫做静态分派，主要存在于方法**重载**阶段，特点是根据**传入参数**决定。

```java
public static void sayHello(Human human){}//方法1
public static void sayHello(Man man){}//方法2
Human h1 = new Man();
sayHello(h1);//实际调用的是方法1
```

静态分派发生在编译阶段，编译器会为其分配一个合适的重载版本，但是重载版本往往不是唯一的，而是相对合适的（不存在*对应其静态分派的重载*则会将传入参数进行*类型转换*后查找匹配的重载）。

**动态分派**：动态分配则主要存在于**重写**阶段，由调用者的实际类型的方法决定。当调用invokevirtual时，首先会找到操作数栈顶的第一个元素所指向对象的实际类型C，然后在类型C中找到与常量中描述符和简单名称都对应的方法进行执行，如果不存在则从下往上（子类-->父类）层层往上找。

例：

```JAVA
class Father{
    public int money = 1;
    public Father(){
        money = 2;
        showMoney();
    }
    public void showMoney(){
        System.out.println("Father" + money);
    }
}
class Son{
    public int money = 3;
    public Son(){
        money = 4;
        showMoney();
    }
    public void showMoney(){
        System.out.println("Son" + money);
    }
}
public static void main(String[] args){
    Father guy = new Son();
    System.out.println("Guy" + guy.money);
}
//输出结果
//Son0
//Son4
//Guy2
```

调用子类构造方法的时候会隐式调用父类构造方法，为父类的money设置值，然后动态分派时调用子类的showMoney()方法，此时子类的money还没有赋值，所以输出结果是0. **动态分派即重写时都是看实际调用者是谁**。

动态分派的实现：在方法区中维护了一个虚方法表，对应了方法和各个方法的**实际**入口地址，如果子类重写了父类的方法则地址是子类重写的方法的地址，否则是父类的方法的地址。

##### 前端编译：将类转换为字节码的过程

JAVA语法糖-泛型擦除：在JAVA中所有的泛型在实际编译时都会被擦除，List<Integer>和List<String>会被编译器认为是同一种类型，如果作为同名函数的不同输入的话将无法通过重载。

##### 后端编译：将字节码转换为机器码的过程

解释器：逐行将字节码解释成机器码后执行。

编译器：将热点代码编译成机器码后执行。

热点代码判定方法：被多次调用的方法或者被多次执行的循环体。可以通过基于采样的热点检测（周期检测各个线程的调用栈顶）或者基于计数器的热点检测（检测方法的调用次数以及循环的回边次数）。

提前编译器与即时编译器：

- 提前编译器：目前有2种方式，程序运行前将程序代码编译成机器码，或者是提前将即时编译器的工作做了然后保存下来。

- 即时编译器要进行过程间分析，耗费时间，但动态分析更能看出程序运行的偏好性，并且可以进行激进的预测性优化。

 ##### 编译器优化技术

- 方法内联：将目标方法的代码原封不动的复制到调用方法之中，可以除去方法调用的成本（查找入口，建立栈帧等），也可以为之后的优化做准备
- 逃逸分析：分析对象的动态作用域，看是否逃离方法或者线程。如果逃逸程度低可以做不同的优化，如栈上分配，标量替换（创建对象的时候不去创建对象，而是创建一些基本类型作为替换），同步消除（没有竞争则消除锁）
- 公共子表达式消除：如果一个表达式E被计算过了并且它的值没有发生变化，那就没必要重新进行计算
- 数组边界检查消除：如果可以判断出数组的访问不会越界，那就不会进行数组边界的检查。

## JAVA内存模型

JAVA内存模型的主要目的是定义程序各种共享变量的访问规则。JAVA内存模型规定了所有的变量都存储在**主内存**，每条线程还有自己的**工作内存**，线程的工作内存种保存了被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作内存中完成，而不能直接读写主内存中的数据。不同线程也不能访问对方的工作内存。

JAVA内存模型提供的操作：

lock/unlock/read/load/use/assign/store/write

##### 对volatile型变量的特殊规则

一是保证该变量对所有线程的可见性（通过在使用被修饰的变量前都必须从主内存中刷新它的值，在更新被修饰的变量后都必须立马写回主内存），二是保证指令的有序性，但是不保证并发下的安全问题。

指令重排序是指处理器允许将多条指令不按程序固定的顺序（但保证单线程内最终结果执行正确地）分开发送个各个相应的电路单元进行处理。

volatile的消耗：读操作基本和不加volatile没有区别；写操作的话会慢一点，因为会加上内存屏障保证处理器不乱序执行（具体的操作是在更改工作线程中的变量值后执行一个字节码层面的[lock + 空操作]，目的是将本处理器的缓存写入内存并且让其他处理器的缓存无效化。这样导致了对volatile变量的更改立马同步到了主内存中，并且之前的内容也一并写入了主内存中，就保证了可见性和指令有序性）。

##### 原子性

read/load/assign/use/store/write的操作是保证原子性的，所以大致可以认为基本数据的访问和读写都是具备原子性的，如果需要更大范围的原子性保证，JVM提供了lock/unlock操作，具体是通过更高层次字节码monitorenter/monitorexit完成的。

##### 可见性

volatile/synchronized/final都可以保证可见性。volatile是通过读前刷新+写后刷新实现可见性的；synchronized是通过对一个变量执行unlock操作前必须将此变量同步回主内存中(store/write)完成的；final是指被final修饰的字段一旦被初始化完成就对其他线程可见。

##### 有序性

JVM的有序性可以总结为如果在本线程内观察，那么所有操作都是有序的；如果在一个线程内观察其他线程，那么所有操作都是无序的。前者主要是指“线程内表示为串行的语义”（即线程中即使指令重排序了也不会改变最后结果），后者是指“指令重排序”现象和“工作内存和主内存存在同步延迟”现象。JVM可以通过volatile和synchronized实现有序性。

##### Happens-Before原则

- 程序次序规则：同一个线程内按照指令流顺序
- 管程锁定规则：对一个变量的解锁和再次加锁
- volatile变量规则：对volatile的写发生于之后的读之前
- 线程启动规则：Thread::start()前后
- 线程终止规则：Thread::join()/Thread::isAlive()前后
- 线程中断规则：Thread::interrupt()/Thread::interrupted()前后
- 对象终结规则：对象的初始化完成先于finalize()开始
- 传递性：A Before B , B Before C, 则 A Before C.

线程的实现方式：内核线程实现（1:1）、用户线程实现（1:N），混合线程实现（N:M)

内核线程实现：内核线程是指由操作系统内核支持的线程，程序不会直接使用内核线程，而是使用内核线程的一个高级接口--轻量级进程，每个轻量级进程都由一个内核线程进行支持。内核线程的各个操作都需要系统调用，即需要进行内核态和用户态的转变，同时也要消耗一定的内核栈资源。

用户线程实现：线程的创建切换调度都是在用户态完成，系统内核无法感知用户态线程的存在以及切换。线程的一系列操作是由用户程序自己设计的。

混合线程实现：内核线程实现和用户线程实现都存在的情况。

JAVA的线程实现是内核线程实现，JAVA的线程调度是抢占式线程调度。（协同式调度：线程的执行时间由线程自己控制；抢占式调度：线程的执行时间由操作系统控制）

协程是协同式调度的用户线程实现。

#### 线程安全

当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度与交替，也不需要额外的同步，调用这个对象的行为都能获得正确的结果，则称这个对象是线程安全的。

JAVA中的线程安全：

- 不可变：不可变的对象一定是线程安全的
- 相对线程安全：对该对象的单次操作是线程安全的
- 绝对线程安全/线程兼容/线程对立

JAVA线程安全实现方式：

互斥同步：在互斥同步的语境下，同步是指在多个线程并发访问共享数据的时候，保证共享数据在同一时刻只被一个或多个线程使用，而互斥（信号量、互斥量、锁等）是同步的一种实现手段。

非阻塞同步：CAS

无同步方案：可重入代码（一段代码不依赖全局变量或者堆中资源，可以在任何时刻中断它去执行另外一段代码）；线程本地存储（如果一段代码的数据必须要和其他代码共享，则看看这些共享数据的代码是否是在一个线程当中）

