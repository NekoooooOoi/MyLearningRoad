### 网络流问题

网络流：**G(V,E)**是一个有限的有向图。它的每条边 **(u,v)∈E**都有一个非负值实数的容量**c(u,v) **。如果**(u,v)**不属于 **E**，我们假设**c(u,v)=0**。我们区别两个顶点：一个源点**s**和一个汇点**t**。一道网络流是一个对于所有结点**u**和**v**都有以下特性的实数函数**f(u,v)**：

容量限制 (Capacity Constraints): **f(u,v)≤c(u,v)**一条边的流不能超过它的容量。

斜对称 (Skew Symmetry): **f(u,v)=−f(v,u)**由 u到 v的净流必须是由 v到 u的净流的相反。

流守恒 (Flow Conservation):除非 u=s或 u=t，否则 **∑w∈V f(u,w)=0**——结点的净流是零，除了“制造”流的源点和“消耗”流的汇点。

可行流：若一个流对每一发点满足总流出量与总流入量之差不大于提供能力，对每一收点满足总流入量与总流出量之差不小于接收能力，则称这个流为可行流。

***

#### 最大流问题：

反向弧：若从u到v的边的容量为c ，这条边上有流量 f 流过（称为正向弧），则相当于v到u有一条容量为0的边，其流量为- f ，这条边就是反向弧。

残余网络：计算出图中的每条边上容量与流量之差（称为残余容量），即可得到残余网络。注意由于反向边的存在，残余网络中的边数可能到达原图中边数的两倍。

增广路径：残余网络中任何一条从s到t的有向道路都对应一条原图中的增广路径 —— 只要求出该道路中所有残量的最小值d ，把对应的所有边上的流量增加d 即可，这个过程称为增广。

最大流定理：如果残留网络上找不到增广路径，则当前流为最大流；反之，如果当前流不为最大流，则一定有增广路径。

##### EK算法：

```
每次使用BFS从残余网络中找到从s到t的一条增广路径（可以使用反向边，如r(u,v)=c(u,v)-f(u,v), r(v,u)=c(v,u)-f(v,u)=c(u,v)+f(u,v), r(u,v)和r(v,u)都是可以被使用的）。
```

##### Dinic算法：

```java
/**
Dinic算法构建层次网络一次完成所有增广，相较于EK效率更高更快。
1、建立网络，将总流量置0。
2、构建层次网络，即进行源点到汇点的可达性分析，并且对每一个点都定层次，若与源点不连通，层次置为-1，利用BFS做到。
3、判断汇点是否为-1。
4、用DFS完成所有增广。
5、回到步骤2.
*/
public class Main {
    static int edge_num = -1;//标记edge的编号，0和1(2和3；以此类推）为一对反向边。这样可以利用u^1=v迅速得到反向边。
    static int[] head;//head[i]代表第i个节点的第一条边是map数组中的第几个，如果不存在则为-1。
    //Edge中的next代表着与head[i]同样的含义，这样可以将同一个点的边用链表形式组合起来
    static Edge[] map;//存放着所有的边
    static int[] depth;//存放层次

    public static void main(String[] args) {
        //初始化
        int n = 4, m = 5;//n为点数，m为边数
        int[] from = {1, 1, 2, 2, 3};
        int[] to = {2, 3, 3, 4, 4};
        int[] cap = {1, 1, 1, 1, 1};
        head = new int[]{0, -1, -1, -1, -1};
        map = new Edge[m * 2 + 1];
        for (int i = 0; i < 5; i++) {
            addEdge(from[i], to[i], cap[i]);
            addEdge(to[i], from[i], 0);
        }
        //Dinic
        int max_flow = 0;
        while (BFS()) {
            max_flow += DFS(1, Integer.MAX_VALUE);
        }
        System.out.println(max_flow);
    }

    public static int DFS(int u, int flow) {
        if (u == 4) return flow;
        int all_out = 0;
        for (int i = head[u]; i != -1; i = map[i].next) {
            int v = map[i].to;
            int res = map[i].residual;
            if ((depth[v] == depth[u] + 1) && res > 0) {
                int out = DFS(v, Math.min(res, flow));
                flow -= out;
                all_out += out;
                map[i].residual -= out;
                map[i ^ 1].residual += out;
                if (flow == 0) break;
            }
        }
        if (all_out == 0) depth[u] = -1;
        return all_out;
    }

    public static boolean BFS() {
        depth = new int[]{0, 0, -1, -1, -1};
        LinkedList<Integer> queue = new LinkedList<>();
        queue.offer(1);
        while (!queue.isEmpty()) {
            int cur = queue.poll();
            for (int i = head[cur]; i != -1; i = map[i].next) {
                int to = map[i].to;
                int res = map[i].residual;
                if (depth[to] == -1 && res > 0) {
                    depth[to] = depth[cur] + 1;
                    queue.offer(to);
                }
            }
        }
        return (depth[4] != -1);
    }

    public static void addEdge(int from, int to, int residual) {
        map[++edge_num] = new Edge(to, head[from], residual);
        head[from] = edge_num;
    }


}

class Edge {
    int to;
    int next;//(u,v)中的u的下一条边在map中的位置
    int residual;//残余容量

    public Edge(int to, int next, int residual) {
        this.to = to;
        this.next = next;
        this.residual = residual;
    }
}

```



#### 最小费用最大流问题：

费用：给定的网络**G(V,E)**的每一条边除了有容量以及流量属性外，还有费用属性**w(u,v)**。

最小费用最大流即是对一个费用容量网络，具有**相同流量f**的可行流中，总费用最小的可行流称为该费用容量网络关于流量f的最小费用流。

##### SPFA算法：

```java
/**
SPFA算法利用贪心的思想，首先计算出从s到t的最小费用以及最大可行流大小，然后进行这条路径的增广，直到没有路径可增广则为最小费用最大流。
算法：
用dis数组记录源点到有向图上任意一点距离，其中源点到自身距离为0，到其他点距离为INF。将源点入队，标记为已访问，并重复以下步骤：（已访问的点意味着该点在队列中，出队后需要标记为未访问，方便后续再次更新）
1、队首t出队，并将t标记为没有访问过，方便下次入队更新。
2、遍历所有以队首为起点的有向边(s,u),如果dis[u]>dis[s]+w(s,u),则更新d[u]。
3、如果点u不在队列中，则u入队，并将u标记为访问过。
4、如果队列为空则跳出循环，否则进行下一步。
*/
public class Main {
    static int edge_num = -1;//标记edge的编号，0和1(2和3；以此类推）为一对反向边。这样可以利用u^1=v迅速得到反向边。
    static int[] head;//head[i]代表第i个节点的第一条边是map数组中的第几个，如果不存在则为-1。
    //Edge中的next代表着与head[i]同样的含义，这样可以将同一个点的边用链表形式组合起来
    static Edge[] map;//存放着所有的边
    static int[] vis;//存放访问次数
    static int[] pre;//上一个节点
    static int[] curCost;//现在节点要花费的所有费用
    static int[] lastEdge;//现在节点的上一条边
    public static int flow;


    public static void main(String[] args) {
        //初始化
        int n = 6, m = 8;//n为点数，m为边数
        int[] from = {1, 1, 2, 2, 3, 4, 5, 5};
        int[] to = {2, 3, 4, 5, 5, 6, 2, 6};
        int[] cap = {10, 8, 7, 2, 10, 6, 4, 7};
        int[] cost = {3, 2, 2, 5, 4, 1, 1, 4};
        head = new int[]{-1, -1, -1, -1, -1, -1, -1};
        map = new Edge[m * 2 + 1];
        for (int i = 0; i < m; i++) {
            addEdge(from[i], to[i], cap[i], cost[i]);
            addEdge(to[i], from[i], 0, -cost[i]);
        }
        //SPFA
        int maxFlow = 0;
        int minCost = 0;
        while (SPFA()) {
            maxFlow += flow;
            minCost += curCost[6] * flow;
            int now = 6;
            while (now != 1) {
                int i = lastEdge[now];
                map[i].residual -= flow;
                map[i ^ 1].residual += flow;
                now = pre[now];
            }
        }
        System.out.println(maxFlow);
        System.out.println(minCost);
    }

    public static boolean SPFA() {
        vis = new int[1 + 6];
        curCost = new int[1 + 6];
        Arrays.fill(curCost, Integer.MAX_VALUE);
        pre = new int[1 + 6];
        lastEdge = new int[17];
        vis[1] = 1;
        curCost[1] = 0;
        pre[6] = -1;
        LinkedList<Integer> queue = new LinkedList<>();
        queue.offer(1);
        flow = Integer.MAX_VALUE;
        while (!queue.isEmpty()) {
            int cur = queue.poll();
            vis[cur] = 0;
            for (int i = head[cur]; i != -1; i = map[i].next) {
                int to = map[i].to;
                int thisCost = map[i].cost;
                int res = map[i].residual;
                if (res > 0 && (thisCost + curCost[cur] < curCost[to])) {
                    curCost[to] = thisCost + curCost[cur];
                    vis[to] = 1;
                    queue.offer(to);
                    pre[to] = cur;
                    lastEdge[to] = i;
                    flow = Math.min(flow, res);
                }
            }
        }
        if (flow == Integer.MAX_VALUE) flow = 0;
        return (pre[6] != -1);
    }

    public static void addEdge(int from, int to, int residual, int cost) {
        map[++edge_num] = new Edge(to, head[from], residual, cost);
        head[from] = edge_num;
    }


}

class Edge {
    int to;
    int next;//(u,v)中的u的下一条边在map中的位置
    int residual;//残余容量
    int cost;

    public Edge(int to, int next, int residual, int cost) {
        this.to = to;
        this.next = next;
        this.residual = residual;
        this.cost = cost;
    }
}
```



